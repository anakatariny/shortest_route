def Dijsktra(graph, origin, destination):
    """
    Dijsktra algorithm in python adapted to the proposed problem (bidirectional and returning the value of the
    calculated distance)
    """
    # shortest paths is a vector of nodes
    shortest_paths = {origin: (None, 0)}
    current_node = origin
    visited = set()

    while current_node != destination:
        visited.add(current_node)
        destinations = graph.edges[current_node]
        distance_to_current_node = shortest_paths[current_node][1]
        # after passing through the graph looks in every possible target generated by the graph
        for next_node in destinations:
            distance = graph.weights[(current_node, next_node)] + distance_to_current_node
            if next_node not in shortest_paths:
                shortest_paths[next_node] = (current_node, distance)
            else:
                current_shortest_distance = shortest_paths[next_node][1]
                # compares the distances to choose the nearest point
                if current_shortest_distance > distance:
                    shortest_paths[next_node] = (current_node, distance)
        # makes a dictionary of unvisited nodes
        next_destinations = {}
        for node in shortest_paths:
            if node not in visited:
                next_destinations[node] = shortest_paths[node]

        if not next_destinations:
            return "This route is not possible"
        # next node is the destination with the lowest distance... in A-B the next destination is B
        def next_move(k):
            return next_destinations[k][1]

        current_node = min(next_destinations, key=next_move)

    # Work back through destinations in shortest route
    complete_route = []
    cost = None
    if current_node is not None:
        cost = shortest_paths[current_node][1]
    while current_node is not None:
        complete_route.append(current_node)
        next_node = shortest_paths[current_node][0]
        current_node = next_node
    # reverses the complete_route to get the direction origin -> destination
    complete_route = complete_route[::-1]
    # inserts the final distance at the end of the vector
    if cost is not None:
        complete_route.append(cost)
    return complete_route
